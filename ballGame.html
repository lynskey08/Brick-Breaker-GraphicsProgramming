<!DOCTYPE html>

<html>

  <head>
    <meta charset="UTF-8">
    <title>Canvas</title>

    <style type="text/css">
      body {
          background-color: white;
      }
      /*Creates canvas with black border in the center*/
      canvas{
         display: block;
         position: absolute;
         margin: auto;
         border: 1px solid black;
      }
    </style>

  </head>

  <body>

    
    <canvas id="Canvas" height="550" width="1000"></canvas>

    <script type="text/javascript">

      // Gets a handle to the element with id canvasOne.
      var canvas = document.getElementById("Canvas");
      // Get a 2D context for the canvas.
      var ctx = canvas.getContext("2d");
       
      //ball object variables
      var ball = {"x": canvas.width/4, "y": 100, "r": 10, "velocityX": 3, "velocityY": 3};
       
      //paddle object variables with drawPaddle function inside
      var paddle = {
            position: {
                x: 530,//places the paddle 530px down as the height of the canvas is 550px giving only 20px for the paddle height
                y: 470//the starting position of the paddle on the x-axis on the bottom of the canvas
            },
            size: {
                w: 120,//width of the paddle
                h: 20//height of the paddle
            },
            //Draw the paddle function
            drawPaddle: function(){ 
                //ctx.beginPath();
              ctx.fillRect(paddle.position.y, paddle.position.x, paddle.size.w, paddle.size.h); //draws the paddle and positions it
                //ctx.closePath();
            }
       }
      
       //brick object variables
      var brick = {
          rows: 3,
          columns: 5,
          width: 75,
          height: 20,
          padding: 10,//the padding between the bricks so they wont touch eachother
          topOffSet: 30,//the offsets is so that the bricks wont be drawn directly from the edge of the canvas
          leftOffSet: 30;
      }
      
      //bricks two dimensional array - all bricks will be held here
      var bricks = [];
      for(c = 0; c < colCount; c++) {//brick columns
          bricks[c] = [];
          for(r = 0; r < rowCount; r++) {brick rows
              bricks[c][r] = { x: 0, y: 0 };//to position the bricks
          }
      }


      // Function to draw the ball
      function drawBall() { 
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, 2 * Math.PI);
        ctx.fill();//Makes the circle filled in
        ctx.closePath();
      }
      
      //Function to move the left and right arrow keys
      function movePaddle() {
          if (event.keyCode == 39) {//right arrow
              if(paddle.position.y <880){
                  paddle.position.y += 20;
              }     
          }
          else if (event.keyCode == 37) {//left arrow key
              if(paddle.position.y >0){
                  paddle.position.y -= 20;
              }
          }
      }//movePaddle
      
    /*
      //Function to draw the paddle
      function paddle() {
          ctx.beginPath();
          ctx.fillRect(paddleX, canvas.height-paddleH, paddleW, paddleH);
          ctx.closePath();
      }
      */
        
      // A function to repeat every time the animation loops.
      function repeatme() {
        
        //This constantly updates the moving objects so it doesn't leave a single straight line
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        //canvas.width = canvas.width;  
        drawBall();//calls the draw ball function
        
        ctx.beginPath(); 
        paddle.drawPaddle();//calls the drawPaddle function
        ctx.closePath();

		// Stops the animation from leaving the canvas(collision decection).
        if (ball.x + ball.velocityX > canvas.width - ball.r || ball.x + ball.velocityX < ball.r) {
            ball.velocityX  = -ball.velocityX;
        }    
        /*if (ball.y + ball.velocityY + ball.r <= 0) {
            ball.velocityY -= ball.velocityY;
        }*/
          
        if ((ball.y > paddle.position.x - ball.r) && ((ball.x > paddle.position.y &&
                    (ball.x < paddle.position.y + 120))) || (ball.y <= ball.r)){
            ball.velocityY = -ball.velocityY;
        }
        else if (ball.y + ball.velocityY > canvas.height + ball.r) {
            alert("Game over!");
            ball.x = canvas.width/4;
            ball.y = 100;
        }

        // Update the x and y coordinates of the ball to keep it moving.
		ball.x += ball.velocityX;
        ball.y += ball.velocityY;
          
        //Tells the browser you wish to perform an animation 
        //and requests the browser to call a specific function 
        //to update an animation before the next repaint
        //window.requestAnimationFrame(repeatme); 
          
        window.addEventListener('keydown', movePaddle, true);
      } 
        
      // Get the animation going.
      setInterval(repeatme, 10);
      
        
    </script>

  </body>

</html>